// @ts-ignore - Export conflicts/types/template.types';
import { PublicProfileData } from '../../types/profile.types';
import { BrandingSettings } from '../types/creator.types';

export class TemplateValidator {
  /**
   * Validate template compatibility with profile data
   */
  static validateTemplateWithProfile(
    template: TemplateDefinition,
    profileData: Partial<PublicProfileData>
  ): TemplateValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];
    const missingFields: string[] = [];
    const recommendations: string[] = [];

    // Check required fields
    const requiredFields = this.getRequiredFieldsForTemplate(template);

    requiredFields.forEach(field => {
      if (!this.hasProfileField(profileData, field)) {
        missingFields.push(field);
        errors.push(`Required field "${field}" is missing for ${template.name} template`);
      }
    });

    // Check optimal fields
    const optimalFields = this.getOptimalFieldsForTemplate(template);

    optimalFields.forEach(field => {
      if (!this.hasProfileField(profileData, field)) {
        warnings.push(`Field "${field}" would enhance the ${template.name} template`);
        recommendations.push(`Consider adding ${field} to improve template appearance`);
      }
    });

    // Validate specific template requirements
    this.validateTemplateSpecificRequirements(template, profileData, errors, warnings);

    // Check media requirements
    this.validateMediaRequirements(template, profileData, errors, warnings);

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      missingFields,
      recommendations,
    };
  }

  /**
   * Validate branding settings compatibility
   */
  static validateBrandingSettings(branding: BrandingSettings): TemplateValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];
    const recommendations: string[] = [];

    // Validate colors
    if (!this.isValidHexColor(branding.primaryColor)) {
      errors.push('Primary color must be a valid hex color');
    }

    if (!this.isValidHexColor(branding.secondaryColor)) {
      errors.push('Secondary color must be a valid hex color');
    }

    if (!this.isValidHexColor(branding.accentColor)) {
      errors.push('Accent color must be a valid hex color');
    }

    // Check color contrast
    const contrast = this.calculateColorContrast(branding.primaryColor, branding.secondaryColor);
    if (contrast < 4.5) {
      warnings.push('Low contrast between primary and secondary colors may affect readability');
      recommendations.push('Consider adjusting colors for better accessibility');
    }

    // Validate font family
    if (!this.isValidFontFamily(branding.fontFamily)) {
      warnings.push('Font family may not be available on all devices');
      recommendations.push('Consider using web-safe fonts or Google Fonts');
    }

    // Check logo URL if provided
    if (branding.logoUrl && !this.isValidImageUrl(branding.logoUrl)) {
      errors.push('Logo URL is not a valid image URL');
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      missingFields: [],
      recommendations,
    };
  }

  /**
   * Get required fields for a template
   */
  private static getRequiredFieldsForTemplate(template: TemplateDefinition): string[] {
    const baseRequired = ['name', 'title'];

    switch (template.category) {
      case 'creative':
        return [...baseRequired, 'portfolio', 'profileImage'];
      case 'tech':
        return [...baseRequired, 'skills', 'experience'];
      case 'executive':
        return [...baseRequired, 'experience', 'summary'];
      case 'minimal':
        return [...baseRequired, 'summary'];
      default:
        return baseRequired;
    }
  }

  /**
   * Get optimal fields for better template appearance
   */
  private static getOptimalFieldsForTemplate(template: TemplateDefinition): string[] {
    const baseOptimal = ['summary', 'profileImage', 'skills'];

    switch (template.category) {
      case 'creative':
        return [...baseOptimal, 'portfolio', 'socialLinks'];
      case 'tech':
        return [...baseOptimal, 'portfolio', 'certifications'];
      case 'executive':
        return [...baseOptimal, 'testimonials', 'certifications'];
      case 'minimal':
        return [...baseOptimal, 'experience'];
      default:
        return baseOptimal;
    }
  }

  /**
   * Check if profile has a specific field with content
   */
  private static hasProfileField(profileData: Partial<PublicProfileData>, field: string): boolean {
    const value = profileData[field as keyof PublicProfileData];

    if (value === null || value === undefined) return false;
    if (typeof value === 'string') return value.trim().length > 0;
    if (Array.isArray(value)) return value.length > 0;
    if (typeof value === 'object') return Object.keys(value).length > 0;

    return true;
  }

  /**
   * Validate template-specific requirements
   */
  private static validateTemplateSpecificRequirements(
    template: TemplateDefinition,
    profileData: Partial<PublicProfileData>,
    errors: string[],
    warnings: string[]
  ): void {
    switch (template.category) {
      case 'creative':
        if (!profileData.portfolio || profileData.portfolio.length === 0) {
          warnings.push('Creative template works best with portfolio items');
        }
        break;

      case 'tech':
        if (!profileData.skills || profileData.skills.length < 5) {
          warnings.push('Tech template is most effective with 5+ skills listed');
        }
        break;

      case 'executive':
        if (!profileData.experience || profileData.experience.length < 2) {
          warnings.push('Executive template should showcase multiple leadership roles');
        }
        break;
    }
  }

  /**
   * Validate media requirements
   */
  private static validateMediaRequirements(
    template: TemplateDefinition,
    profileData: Partial<PublicProfileData>,
    errors: string[],
    warnings: string[]
  ): void {
    // Check profile image
    if (template.category === 'creative' && !profileData.profileImage) {
      warnings.push('Profile image is important for creative templates');
    }

    // Check portfolio images
    if (profileData.portfolio) {
      profileData.portfolio.forEach((item, index) => {
        if (!item.imageUrl && template.category === 'creative') {
          warnings.push(`Portfolio item ${index + 1} missing image for creative template`);
        }
      });
    }
  }

  /**
   * Validate hex color format
   */
  private static isValidHexColor(color: string): boolean {
    return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);
  }

  /**
   * Calculate color contrast ratio
   */
  private static calculateColorContrast(color1: string, color2: string): number {
    // Simplified contrast calculation
    const luminance1 = this.getColorLuminance(color1);
    const luminance2 = this.getColorLuminance(color2);

    const lighter = Math.max(luminance1, luminance2);
    const darker = Math.min(luminance1, luminance2);

    return (lighter + 0.05) / (darker + 0.05);
  }

  /**
   * Get color luminance
   */
  private static getColorLuminance(hex: string): number {
    const rgb = this.hexToRgb(hex);
    if (!rgb) return 0;

    const [r, g, b] = [rgb.r, rgb.g, rgb.b].map(c => {
      c = c / 255;
      return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    });

    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
  }

  /**
   * Convert hex to RGB
   */
  private static hexToRgb(hex: string): { r: number; g: number; b: number } | null {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  /**
   * Validate font family
   */
  private static isValidFontFamily(fontFamily: string): boolean {
    const webSafeFonts = [
      'Arial', 'Helvetica', 'Times New Roman', 'Times', 'Courier New',
      'Verdana', 'Georgia', 'Palatino', 'Garamond', 'Comic Sans MS',
      'Trebuchet MS', 'Arial Black', 'Impact', 'Inter', 'Roboto'
    ];

    return webSafeFonts.some(font =>
      fontFamily.toLowerCase().includes(font.toLowerCase())
    );
  }

  /**
   * Validate image URL
   */
  private static isValidImageUrl(url: string): boolean {
    try {
      const urlObj = new URL(url);
      const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg'];
      return imageExtensions.some(ext =>
        urlObj.pathname.toLowerCase().endsWith(ext)
      );
    } catch {
      return false;
    }
  }
}